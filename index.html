<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
</head>
<body>

<!-- material design -->	
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.brown-deep_orange.min.css" />
<script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>

<link rel="stylesheet" href="style.css" />

<script src="MathUtil.js"></script>
<script src="Rect2D.js"></script>
<script src="Vector2D.js"></script>
<script src="Animation.js"></script>
<script src="DragHelper.js"></script>
<script src="DraggableNumber.js"></script>
<script src="CtxUtil.js"></script>

<div id="app">
	<div id="game-controls" >
		<div id="essential-controls-spacer"></div>
		<div id="essential-controls">
			<button id="restart-button" style="/*background: #ffffff33;*/" class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect">
				<i class="material-icons">refresh</i>
			</button>
			<div id="cur-stats-container">
				<div class="stats-value-wrapper">
					<i class="material-icons">touch_app</i>
					<span id="number-moves-element">0</span>
				</div>
				<div class="stats-value-wrapper">
					<i class="material-icons">access_time</i>
					<span id="elapsed-time-element">0s</span>
				</div>
			</div>
		</div>
		<!--<div class="stats-value-wrapper" style="z-index: 3;">
			<i class="material-icons">photo_camera</i>
			<div id="delta-time-element">
				<div id="delta-time-indicator"></div>
			</div>
		</div>-->
		<div id="spacer"></div>
		<button id="settings-button" class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect">
			<div>
				<i class="material-icons">settings</i>
			</div>
		</button>
	</div>
	<div id="canvas-wrapper">
		<div class="canvas-padder" id="left-canvas-padder"></div>
		<canvas></canvas>
		<div class="canvas-padder"></div>
	</div>
	<div id="settings-container" class="overlay">
		<div id="settings-wrapper">
			<div style="display: flex;">
				<span>scramble on start</span>
				<div style="display: flex; align-items: center; margin-left: 30px;">
					<label class="mdl-switch mdl-js-switch mdl-js-ripple-effect" for="scramble-on-start-input">
						<input type="checkbox" id="scramble-on-start-input" class="mdl-switch__input">
					</label>
				</div>
			</div>
			<!-- tile-board size -->
			<div id="tile-board-size-container">
				<span class="size-label">width</span>
				<draggable-number id="width-input" min="2" max="30" value="3" spacing="50"></draggable-number>
				<span class="size-label">height</span>
				<draggable-number id="height-input" min="2" max="30" value="3" spacing="50"></draggable-number>
			</div>
			<!-- fill style -->
			<div>
				<span>tilecolor</span>
				<div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label mdl-select">
					<select class="mdl-textfield__input" id="gradient-input">
						<option selected value="continuous">continuous gradient</option>
						<option value="discrete">discrete gradient</option>
						<option value="none">simple</option>
					</select>
				</div>
			</div>
			<!-- board shape -->
			<div>
				<span>shape</span>
				<div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label mdl-select">
					<select class="mdl-textfield__input" id="gradient-input">
						<option selected value="rect">rect</option>
						<option value="rect">disc</option>
					</select>
				</div>
			</div>
			<!-- drag method -->
			<div>
				<span>dragging method</span>
				<div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label mdl-select">
					<select class="mdl-textfield__input" id="dragging-method-input">
						<option selected value="carykh">carykh</option>
						<option value="spring and snap">spring'n'snap</option>
					</select>
				</div>
			</div>
		</div>
	</div>
</div>

<!-- essential controls alignment -->
<script>
	{
		const leftCanvasPadder = document.querySelector("#left-canvas-padder");
		new ResizeObserver(() => {
			const spacer = document.querySelector("#essential-controls-spacer");
			const canvas = document.querySelector("canvas");
			const canvasPadderWidth = leftCanvasPadder.offsetWidth;
			const controlsWidth = document.querySelector("#essential-controls").offsetWidth;
			const controlsRight = canvasPadderWidth + controlsWidth;
			const settingsButtonLeft = document.querySelector("#settings-button").getBoundingClientRect().left;
			let spacerWidth = 0;
			if (settingsButtonLeft - controlsRight > 180){
				spacerWidth = canvasPadderWidth;
				if (controlsWidth > canvas.offsetWidth){
					spacerWidth -= (controlsWidth - canvas.offsetWidth) / 2;
				}
			}
			spacer.style.width = spacerWidth + "px";
		}).observe(leftCanvasPadder);
	}
</script>

<!-- general util -->
<script>

	const createRectImageData = (ctx, width, height, getPixelAt) => {
		width = Math.ceil(width);
		height = Math.ceil(height);
		const imageData = ctx.createImageData(width, height);
		let counter = 0;
		for (let y = 0; y < height; y++){
			for (let x = 0; x < width; x++){
				const pixelData = getPixelAt(x, y);
				for (let i = 0; i < pixelData.length; i++){
					imageData.data[counter] = pixelData[i];
					counter++;
				}
			}
		}
		return imageData;
	};
	const createRectImage = (width, height, getPixelAt) => {
		width = Math.floor(width);
		height = Math.floor(height);
		const canvas = document.createElement("canvas");
		canvas.width = width;
		canvas.height = height;
		const ctx = canvas.getContext("2d");
		const imageData = createRectImageData(ctx, width, height, getPixelAt);
		ctx.putImageData(imageData, 0, 0);

		let loadResolve = null;
		const loadPromise = new Promise(resolve => loadResolve = resolve);

		const img = document.createElement("img");
		const src = canvas.toDataURL();
		img.onload = () => loadResolve(img);
		img.src = src;

		return loadPromise;
	};

	const getPixelRatio = (ctx) => {
		const dpr = window.devicePixelRatio || 1;
		const bsr = 
			ctx.webkitBackingStorePixelRatio ||
			ctx.mozBackingStorePixelRatio ||
			ctx.msBackingStorePixelRatio ||
			ctx.oBackingStorePixelRatio ||
			ctx.backingStorePixelRatio || 1;

		return dpr / bsr;
	};

</script>

<!-- game -->
<script>
	{

		//ideas and todo:
		//- implement pwa
		//- wait until all icons and images are loaded before showing them
		//- try to take up maximum space, by rearranging layout, for example when phone is 
		//in landscape mode, move the controls and settings of to the sides
		//- gradient-image rendering when dimension do not fit yet (after recalculate)
		//- feedback for when puzzle is completely solved
		//- feedback for initial scramble
		//- prevent overflow of timer, scale it down if too big
		//- scale labels by their size, so they always fit
		//- low poly torus as icon
		//- circular rows
		//- rotate settings icon when clicked
		//- make circular reveal less janky
		//- multi touch
		//- highscores
		//- auto-solve

		//done:
		//- timer, number of moves (Y)
		//- functions, well layout settings (Y)
		//- pause when inactive (window inactive) (Y)
		//- responsive, goodlooking layout (Y)



		const torusSpace = {
			toroidalPointCount: 5,
			poloidalPointCount: 5
		};
		const validateTorusSpaceCoordinates = (toroidalCoordinate, poloidalCoordinate) => {
			return [
				MathUtil.loopNum(0, torusSpace.toroidalPointCount, toroidalCoordinate),
				MathUtil.loopNum(0, torusSpace.poloidalPointCount, poloidalCoordinate)
			];
		};
		window.validateTorusSpaceCoordinates = validateTorusSpaceCoordinates;

		let tileLayer;
		{	
			tileLayer = {};

			const boardManager = tileLayer;

			const getTileSize = () => tileSize;
			const getHorizontalTileCount = () => horizontalSize;
			const getVerticalTileCount = () => verticalSize;
			const getTiles = () => tiles;
			const getBoardRect = () => new Rect2D(0, 0, getHorizontalTileCount(), getVerticalTileCount());

			let boardGridPositionMap;
			boardManager.init = () => {
				boardGridPositionMap = new Map();
				getTiles().forEach(tile => {
					boardGridPositionMap.set(tile, tile.position);
				});
				prevRowDirection = "none";
				rowOffsets = [];
			};

			let rowOffsets = [];
			let prevRowDirection = "none";
			const applyRowOffsets = () => {
				if (prevRowDirection === "none") {
					return;
				}
				for (let offsetEntry of rowOffsets) {
					offsetEntry.offset = Math.round(offsetEntry.offset);
				}
				const alignProps = prevRowDirection === "horizontal" ? ["x", "y"] : ["y", "x"];
				for (let tile of getTiles()) {
					const boardGridPosition = boardGridPositionMap.get(tile);
					const boardGridPositionRowIndex = boardGridPosition[alignProps[1]];
					const currentEntry = rowOffsets.find(entry => entry.index === boardGridPositionRowIndex);
					if (currentEntry !== undefined) {
						const tileOnPlaneGrid = boardGridPosition.copy();
						tileOnPlaneGrid[alignProps[0]] += currentEntry.offset;
						const nextBoardGridPosition = boardManager.planeGridPointToBoardGridPoint(tileOnPlaneGrid);
						boardGridPosition.set(nextBoardGridPosition);
					}
					tile.position = boardGridPosition;
				}
			};
			//rowDirection: "horizontal" || "vertical" || Vector2D
			//rowCoordinate: number || Vector2D
			//deltaMovement: number
			boardManager.moveTileRow = (rowDirection, rowCoordinatePlaneSpace, deltaMovement) => {
				let rowDirectionNamed = "none";
				if (typeof (rowDirection) === "string") {
					rowDirectionNamed = rowDirection;
				}
				else if (rowDirection.x !== undefined && rowDirection.y !== undefined) {
					rowDirectionNamed = Math.abs(rowDirection.x) > Math.abs(rowDirection.y) ? "horizontal" : "vertical";
				}
				else {
					console.error("rowDirection must either be a string or a vector");
				}

				let rowCoordinateVector = null;
				if (typeof (rowCoordinatePlaneSpace) === "number") {
					rowCoordinateVector = rowDirectionNamed === "horizontal" ?
						new Vector2D(0, rowCoordinatePlaneSpace) : new Vector2D(rowCoordinatePlaneSpace, 0);
				}
				else if (rowCoordinatePlaneSpace.x !== undefined && rowCoordinatePlaneSpace.y !== undefined) {
					rowCoordinateVector = rowCoordinatePlaneSpace;
				}
				else {
					console.error("rowCoordinate must either be a number or a vector");
				}
				const rowCoordinateBoardGridSpace = boardManager.planePointToBoardGridPoint(rowCoordinateVector);
				const boardRowIndex = rowDirectionNamed === "horizontal" ? rowCoordinateBoardGridSpace.y : rowCoordinateBoardGridSpace.x;

				if (rowDirection !== prevRowDirection) {
					applyRowOffsets();
					rowOffsets = [];
				}

				//add offset to entry
				let offsetEntry = rowOffsets.find(offsetEntry => offsetEntry.index === boardRowIndex);
				if (offsetEntry === undefined) {
					offsetEntry = {
						index: boardRowIndex,
						offset: 0
					};
					rowOffsets.push(offsetEntry);
				}
				const offsetBefore = offsetEntry.offset;
				offsetEntry.offset += deltaMovement;

				//apply current offset to tiles
				const alignProps = rowDirection === "horizontal" ? ["x", "y"] : ["y", "x"];
				for (let tile of getTiles()) {
					const boardGridPosition = boardGridPositionMap.get(tile);
					const boardGridPositionRowIndex = boardGridPosition[alignProps[1]];
					const currentEntry = rowOffsets.find(entry => boardRowIndex === boardGridPositionRowIndex);
					if (currentEntry !== undefined) {
						const tilePosition = boardGridPosition.copy();
						tilePosition[alignProps[0]] += offsetEntry.offset;
						tile.position = tilePosition;
					}
				}

				//move count
				const numberOfMoves = Math.abs(Math.round(offsetEntry.offset) - Math.round(offsetBefore));
				boardManager.dispatchEvent(new CustomEvent("rowGridPositionChanged", {
					detail: {
						rowDirection: rowDirectionNamed,
						rowIndex: boardRowIndex,
						deltaGridPosition: numberOfMoves
					}
				}));

				prevRowDirection = rowDirection;
				app.requestRender();
			};
			boardManager.stopTileRowMoving = () => {
				applyRowOffsets();
				rowOffsets = [];
				prevRowDirection = "none";
				boardManager.dispatchEvent(new CustomEvent("rowMovingStopped"));
				app.requestRender();
			};
			boardManager.checkIntegrity = () => {
				const tiles = getTiles();
				let integrityPassed = true;

				const misalignedTiles = tiles.filter(tile => tile.position.x % 1 !== 0 || tile.position.y % 1 !== 0);
				if (misalignedTiles.length > 0) {
					integrityPassed = false;
					console.warn("found tiles that are not aligned!", misalignedTiles);
				}

				const outOfBoardTiles = tiles.filter(tile => {
					return tile.position.x < 0 || tile.position.x > getHorizontalTileCount() ||
						tile.position.y < 0 || tile.position.y > getVerticalTileCount();
				});
				if (outOfBoardTiles.length > 0) {
					integrityPassed = false;
					console.warn("found tiles that are out of bounds!", outOfBoardTiles);
				}

				const stackedTiles = tiles.filter(tile => {
					return tiles.some(otherTile => {
						if (tile === otherTile) {
							return;
						}
						return tile.position.equals(otherTile.position);
					});
				});
				if (stackedTiles.length > 0) {
					integrityPassed = false;
					console.warn("found tiles on top of each other", stackedTiles);
				}

				if (integrityPassed) {
					console.log("all tiles are ok!");
				}
			};
			boardManager.areTileGridPositionsInInitialState = () => {
				return getTiles().every(tile => {
					const tileBoardGridPoint = boardGridPositionMap.get(tile);
					return tileBoardGridPoint.equals(tile.initialPosition);
				});
			};

			boardManager.performRandomMoves = (numberOfMoves) => {
				const verticalSize = getVerticalTileCount();
				const horizontalSize = getHorizontalTileCount();
				const tiles = getTiles();
				for (let a = 0; a < numberOfMoves; a++) {
					const rowDirection = Math.random() > 0.5 ? "horizontal" : "vertical";
					const maxIndex = rowDirection === "horizontal" ? verticalSize : horizontalSize;
					let rowIndex = Math.floor(Math.random() * maxIndex);
					if (rowIndex >= maxIndex) {
						rowIndex = maxIndex;
					}
					const rowSize = rowDirection === "horizontal" ? horizontalSize : verticalSize;
					const maxStride = rowSize - 1;
					const stride = 1 + Math.floor(Math.random() * (maxStride - 1));
					const positionProps = rowDirection === "horizontal" ? ["x", "y"] : ["y", "x"];
					const rowTiles = tiles.filter(tile => tile.position[positionProps[1]] === rowIndex);
					for (let tile of rowTiles) {
						let positionComp = tile.position[positionProps[0]] + stride;
						positionComp = loopNum(0, rowSize, positionComp);
						tile.position[positionProps[0]] = positionComp;
					}
				}
			};
		}




		//Vector ###
		{
			Vector2D.prototype.toTileSpace = function () {
				return tileBoard.canvasPointToPlanePoint(this);
			};
			Vector2D.prototype.signed = function () {
				return this.transformedComponents(c => Math.sign(c));
			};
			Vector2D.prototype.plusHalf = function () {
				return this.transformedComponents(c => c + 0.5);
			};
		}


		class Tile {
			constructor(args){
				args = args || {};
				this.imageData = args.imageData || null;
				this.label = args.label || "";
				this.position = args.position || new Vector2D();
				this.initialPosition = args.initialPosition || new Vector2D();
			}
		}

		//Math Utils ###
		const [getLineToGridLineIntersections, loopNum] = [MathUtil.getLineToGridLineIntersections, MathUtil.loopNum];

		const app = new EventTarget();
		window.app = app;

		let horizontalSize = 4;
		let verticalSize = 4;
		app.addEventListener("configChanged", e => {
			horizontalSize = e.detail.config.numberOfHorizontalTiles;
			verticalSize = e.detail.config.numberOfVerticalTiles;
		});

		let tileSize = 0;

		//tiles ###
		let tiles = [];
		app.getTiles = () => tiles;
		const getTileByLabel = tileLabel => {
			return tiles.find(tile => tile.label === tileLabel);
		};
		const getLabelByTile = (tile) => {
			return (tile.initialPosition.y * horizontalSize + tile.initialPosition.x + 1).toString();
		};
		const initTiles = () => {
			tiles = [];
			for (let a = 0; a < horizontalSize; a++) {
				for (let b = 0; b < verticalSize; b++) {
					const [x, y] = [a, b];
					const tile = new Tile({
						imageData: null,
						position: new Vector2D(x, y),
						initialPosition: new Vector2D(x, y)
					});
					tile.label = getLabelByTile(tile);
					tiles.push(tile);
				}
			}
		};

		let config = null;
		app.applyConfig = (newConfig) => {
			const oldConfig = config;
			config = newConfig;

			app.dispatchEvent(new CustomEvent("configChanged", {
				detail: {
					prevConfig: oldConfig,
					newConfig: config,
					config: config
				}
			}));

			//gradients
			{
				let gradientUpdateDue = false;
				if (oldConfig === null) {
					gradientUpdateDue = false;
				}
				else {
					const oldGradient = oldConfig.style.gradient;
					const newGradient = newConfig.style.gradient;
					gradientUpdateDue = newGradient !== oldGradient && newGradient !== "simple";
				}
				if (gradientUpdateDue) {
					app.dispatchEvent(new CustomEvent("gradientConfigChanged", {
						detail: {
							gradientType: config.style.gradient
						}
					}));
				}
			}

			if (app.gameState !== "not started") {
				tileBoard.stopTileRowMoving();
			}
		};

		//tile-position manager ###
		const tileBoard = new EventTarget();
		window.tileBoard = tileBoard;
		{
			//definitions:
			//board-space: a coordinate system where a unit has the screen-size of a tile and with a fixed size
			//board-grid-space: like board-space but the coordinates are floored => boardSpacePoint.quantized(1)
			//plane-point: like board-space but without a fixed size, goes on infinitely long
			//canvas-point: pixels relative to canvas

			//planePoint: { x: number, y: number }
			boardManager.planePointToBoardPoint = (planePoint) => {
				return planePoint.loopedOverRect(getBoardRect());
			};
			boardManager.planePointToBoardGridPoint = (planePoint) => {
				const boardPoint = boardManager.planePointToBoardPoint(planePoint);
				return boardPoint.quantized(1);
			};
			boardManager.planeGridPointToBoardGridPoint = (planeGridPoint) => {
				return planeGridPoint.loopedOverRect(getBoardRect());
			};
			boardManager.canvasPointToPlanePoint = (canvasPoint) => {
				return canvasPoint.divide(getTileSize());
			};
			boardManager.canvasPointToBoardPoint = (canvasPoint) => {
				return boardManager.planePointToBoardPoint(boardManager.canvasPointToPlanePoint());
			};

			const isNumInLoopRange = (loopSize, rangeStart, rangeSize, num) => {
				const rawRangeEnd = rangeStart + rangeSize;
				const loopedRangeEnd = MathUtil.loopNum(0, loopSize, rawRangeEnd);
				if (rangeStart < loopSize - rangeSize){
					return num >= rangeStart && num <= rawRangeEnd;
				}
				else {
					return num >= rangeStart || num <= loopedRangeEnd;
				}
			};
			boardManager.getTileAtBoardPoint = boardPoint => {
				return getTiles().find(tile => {
					const boardTilePosition = boardManager.planePointToBoardPoint(tile.position);
					return 	isNumInLoopRange(getHorizontalTileCount(), boardTilePosition.x, 1, boardPoint.x) &&
							isNumInLoopRange(getVerticalTileCount(), boardTilePosition.y, 1, boardPoint.y);
				});
			};
			boardManager.getTileAtPlanePoint = planePoint => {
				const boardPoint = boardManager.planePointToBoardPoint(planePoint);
				return boardManager.getTileAtBoardPoint(boardPoint);
			};
		}

		//app state control ###
		{
			const gameStates = {
				"not started": "not started",
				"running": "running",
				"paused": "paused",
				"finished": "finished"
			};

			let gameState = "not started";
			Object.defineProperty(app, "gameState", { get: () => gameState });

			let prevGameState = null;
			Object.defineProperty(app, "prevGameState", { get: () => prevGameState });

			const gameStateTransitions = [
				{ from: "not started", to: "running", transition: "start" },
				{ from: ["finished", "paused", "running"], to: "running", transition: "restart" },
				{ from: "running", to: "paused", transition: "pause" },
				{ from: "paused", to: "running", transition: "resume" },
				{ from: "running", to: "finished", transition: "finish"}
			];
			const getTransitionEntryByStateAndAction = (currentState, desiredTransition) => {
				for (let transitionEntry of gameStateTransitions){
					const fromStates = Array.isArray(transitionEntry.from) ? transitionEntry.from : [transitionEntry.from];
					if (fromStates.includes(currentState) && transitionEntry.transition === desiredTransition){
						return transitionEntry;
					}
				}
			};

			const makeStateTransition = transition => {
				prevGameState = gameState;
				const transitionEntry = getTransitionEntryByStateAndAction(gameState, transition);
				if (!transitionEntry){
					console.warn("cannot make desired transition: " + transition);
					return;
				}

				const nextGameState = transitionEntry.to;
				gameState = nextGameState;

				app.dispatchEvent(new CustomEvent("gameStateChanged", {
					detail: {
						prevGameState: prevGameState,
						curGameState: nextGameState,
						transition: transition
					}
				}));
			};

			let numberOfMoves = 0;
			Object.defineProperty(app, "numberOfMoves", { get: () => numberOfMoves });

			tileBoard.addEventListener("rowGridPositionChanged", e => {
				const numberOfMovesDelta = e.detail.deltaGridPosition;
				if (numberOfMoves === 0){
					makeStateTransition("start");
				}

				numberOfMoves += numberOfMovesDelta;
				app.dispatchEvent(new CustomEvent("rowMoved"));
			});

			tileBoard.addEventListener("rowMovingStopped", e => {
				if (tileBoard.areTileGridPositionsInInitialState()){
					makeStateTransition("finish");
				}
			});

			app.start = () => {
				makeStateTransition("start");
			};
			app.pause = () => {
				makeStateTransition("pause");
			};
			app.resume = () => {
				makeStateTransition("resume");
			};
			app.restart = () => {
				numberOfMoves = 0;
				makeStateTransition("restart");
			};
			app.isIdle = () => {
				return ["not started", "finished"].includes(gameState);
			};
		}

		//canvas, canvas sizing, ctx ###
		let canvas, ctx, getCanvasPixelRatio, updateCanvasSize;
		{
			canvas = document.querySelector("canvas");
			ctx = canvas.getContext("2d");
			let canvasPixelRatio = 1;
			getCanvasPixelRatio = () => canvasPixelRatio;
			updateCanvasSize = () => {
				const canvasWrapper = canvas.parentElement;
				const availableWidth = canvasWrapper.offsetWidth;
				const availableHeight = canvasWrapper.offsetHeight;
				const availableWidthPerHeight = availableWidth / availableHeight;
				const canvasWidthPerHeight = horizontalSize / verticalSize;

				let canvasWidth, canvasHeight;
				if (canvasWidthPerHeight > availableWidthPerHeight){
					canvasWidth = availableWidth;
					canvasHeight = availableWidth * (1 / canvasWidthPerHeight);
				}
				else {
					canvasHeight = availableHeight;
					canvasWidth = availableHeight * canvasWidthPerHeight;
				}
				const scale = 0.95;
				[canvasWidth, canvasHeight] = [canvasWidth, canvasHeight].map(val => Math.floor(val * scale));

				canvasPixelRatio = getPixelRatio(ctx);
				canvas.width = canvasWidth * canvasPixelRatio;
				canvas.height = canvasHeight * canvasPixelRatio;
				canvas.style.width = canvasWidth + "px";
				canvas.style.height = canvasHeight + "px";

				canvas.dispatchEvent(new CustomEvent("resized", { detail: {
					canvasWidth: canvasWidth,
					canvasHeight: canvasHeight
				}}));
			};
			//auto resizing
			new ResizeObserver(updateCanvasSize).observe(canvas.parentElement);
		}


		//general rendering ###
		let renderComponents, requestRender;
		{
			renderComponents = [];

			const render = () => {
				ctx.save();
				ctx.clearRect(0, 0, canvas.width, canvas.height);

				const pixelRatio = getCanvasPixelRatio();
				ctx.scale(pixelRatio, pixelRatio);

				for (let renderComponent of renderComponents){
					renderComponent.render(ctx);
				}

				ctx.restore();
			};

			//request render
			{
				let requestedRender = false;
				requestRender = () => {
					if (requestedRender) {
						return;
					}
					requestedRender = true;
					window.requestAnimationFrame(() => {
						render();
						requestedRender = false;
					});
				};
			}
			app.requestRender = () => requestRender();
		}

		//shape: "rect" ###
		{
			const renderTile = tile => {
				const [x, y] = [tile.position.x, tile.position.y];

				//horizontal looping
				const repeatedX = loopNum(0, horizontalSize, x);
				const repeatedY = loopNum(0, verticalSize, y);
				renderTileAt(tile, repeatedX, repeatedY);

				if (repeatedX > horizontalSize - 1) {
					renderTileAt(tile, repeatedX - horizontalSize, repeatedY);
				}

				if (repeatedY > verticalSize - 1) {
					renderTileAt(tile, repeatedX, repeatedY - verticalSize);
				}
			};
			const renderTileOnRect = (tile, x, y) => {
				ctx.translate(x, y);
	
				//render rect
				if (tile.imageData && config.style.gradient !== "none") {
					ctx.save();
					ctx.setTransform(1, 0, 0, 1, 0, 0);
					const deviceTileSize = tileSize * getCanvasPixelRatio();
					ctx.drawImage(tile.imageData, Math.floor(x * deviceTileSize), Math.floor(y * deviceTileSize));
					ctx.restore();
				}
				if (config.style.gradient === "none") {
					//ctx.fillStyle = "gray";
					//ctx.fillRect(0, 0, 1, 1);
				}
	
				//renderGradientRect(ctx, tile.initialX, tile.initialY);
				ctx.lineWidth = 0.025;
				ctx.strokeStyle = "black";
				ctx.strokeRect(0, 0, 1, 1);
	
				//render label
				const label = tile.label;
				ctx.translate(0.5, 0.5);
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				ctx.font = "1px sans-serif";
				ctx.fillStyle = config.style.gradient === "none" ? "black" : "white";
				ctx.scale(0.5, 0.5);
				ctx.fillText(label, 0, 0);
			};

			canvas.addEventListener("resized", (e) => {
				tileSize = e.detail.canvasWidth / horizontalSize;
			});

			//coordinate mappings:

		}

		//shape: "disc" ###
		let createDiscGradientImageData, renderTileOnDisc, initImageMetrics;
		{
			const polarRenderingConfig = {
				pixelPerRadius: 60,
				radiusPerTile: 1,
				//the center circle has to have a greater radius than any tile
				centerCircleRadius: 1.2,
				lineWidth: 0.025,
				getAnglePerTile: () => (Math.PI * 2) / horizontalSize,
				getOuterRadius: () => polarRenderingConfig.centerCircleRadius + verticalSize * polarRenderingConfig.radiusPerTile
			};

			//image measurements
			initImageMetrics = () => {
				const centerCircleRadius = polarRenderingConfig.centerCircleRadius;
				const radiusPerTile = polarRenderingConfig.radiusPerTile;
				const anglePerTileHalf = polarRenderingConfig.getAnglePerTile() / 2;
				const pixelPerRadius = polarRenderingConfig.pixelPerRadius;
				const outerRadius = polarRenderingConfig.getOuterRadius();
				const radiusPerTileHalf = radiusPerTile / 2;
				const sizingRadius = outerRadius + radiusPerTileHalf;

				const lowerRadius = sizingRadius - radiusPerTileHalf;
				const upperRadius = sizingRadius + radiusPerTileHalf;
				const maxX = Math.sin(anglePerTileHalf) * upperRadius;
				const minY = Math.cos(anglePerTileHalf) * lowerRadius;
				const maxY = upperRadius;
				const width = maxX * 2;
				const height = maxY - minY;
				const middleY = radiusPerTileHalf;

				const imageWidth = width * pixelPerRadius;
				const imageHeight = height * pixelPerRadius;
				polarRenderingConfig.imageMetrics = {
					sizingRadius: sizingRadius,
					width: imageWidth,
					height: imageHeight,
					centerX: imageWidth / 2,
					centerY: middleY * pixelPerRadius
				};
			};

			createDiscGradientImageData = tile => {
				const wheelRadius = polarRenderingConfig.getOuterRadius() * 1.5;
				const wheelRadiusPixels = polarRenderingConfig.pixelPerRadius * wheelRadius;
				polarRenderingConfig.wheelRadiusPixels = wheelRadiusPixels;
				const squareSize = wheelRadiusPixels * 2;
				createRectImage(squareSize, squareSize, (x, y) => {
					return [Math.floor(255 * x / squareSize), Math.floor(255 * y / squareSize), 80, 255];
				}).then(image => polarRenderingConfig.colorWheelImage = image);
				console.log(polarRenderingConfig);
			};
			window.createDiscGradientImageData = createDiscGradientImageData;
			/*createDiscGradientImageData = (tile) => {
				const centerCircleRadius = polarRenderingConfig.centerCircleRadius;
				const radiusPerTile = polarRenderingConfig.radiusPerTile;
				const anglePerTile = polarRenderingConfig.getAnglePerTile();
				const pixelPerRadius = polarRenderingConfig.pixelPerRadius;
				const outerRadius = polarRenderingConfig.getOuterRadius();

				const middleRadius = centerCircleRadius + (tile.initialPosition.y + 0.5) * radiusPerTile;
				const middleAngle = (tile.initialPosition.x + 0.5) * anglePerTile;
				const sizingRadius = polarRenderingConfig.imageMetrics.sizingRadius;
				const sizingFactor = sizingRadius / middleRadius;

				const lowerRadius = sizingRadius - radiusPerTile / 2;
				const upperRadius = sizingRadius + radiusPerTile / 2;
				const maxX = Math.sin(anglePerTile / 2) * upperRadius;
				const minY = Math.cos(anglePerTile / 2) * lowerRadius;
				const maxY = upperRadius;
				const width = maxX * 2;
				const height = maxY - minY;
				const middleY = radiusPerTile / 2;

				const imageWidth = width * pixelPerRadius;
				const imageHeight = height * pixelPerRadius;
				const imageCenter = new Vector2D(imageWidth / 2, middleY * pixelPerRadius);
				const imagePointToDiscSegmentPoint = imagePoint => {
					return imageCenter.vectorTo(imagePoint).scale(1 / (pixelPerRadius * sizingFactor));
				};

				const colorWheelMargin = 20;
				const colorWheelRadius = 255 - colorWheelMargin;
				const boardDiscToColorDiscScale = colorWheelRadius / outerRadius;
				const [sin, cos] = [Math.sin(middleAngle) * boardDiscToColorDiscScale, Math.cos(middleAngle) * boardDiscToColorDiscScale];
				const rotationMatrix = [cos, -sin, sin, cos];
				const centerPointOnColorWheel = new Vector2D(255 / 2, 255 / 2).plus(
					new Vector2D(rotationMatrix[2], rotationMatrix[3]).scale(middleRadius)
				);

				const discSegmentPointToColorWheelPoint = discSegmentPoint => {
					return centerPointOnColorWheel.plus(new Vector2D(
						discSegmentPoint.x * rotationMatrix[0] + discSegmentPoint.y * rotationMatrix[2],
						discSegmentPoint.x * rotationMatrix[1] + discSegmentPoint.y * rotationMatrix[3],
					));
				};

				const getPixelAt = (x, y) => {
					const imagePoint = new Vector2D(x, y);
					const discSegmentPoint = imagePointToDiscSegmentPoint(imagePoint);
					const colorWheelPoint = discSegmentPointToColorWheelPoint(discSegmentPoint);
					return [Math.floor(colorWheelPoint.x), Math.floor(colorWheelPoint.y), 50, 255];
				};
				return createRectImage(imageWidth, imageHeight, getPixelAt);
			};*/

			const makeDiscPathClipping = (ctx) => {
				const halfLineWidth = polarRenderingConfig.lineWidth / 2;
				const radiusPerTile = polarRenderingConfig.radiusPerTile;
				const centerCircleRadius = polarRenderingConfig.centerCircleRadius;
				const maxDiscRadius = centerCircleRadius + radiusPerTile * verticalSize;
				ctx.beginPath();
				ctx.arc(horizontalSize / 2, verticalSize / 2, maxDiscRadius + halfLineWidth, 0, Math.PI * 2);
				ctx.arc(horizontalSize / 2, verticalSize / 2, centerCircleRadius - halfLineWidth, 0, Math.PI * 2, true);
				ctx.closePath();
				ctx.clip();
			};
			/*renderTileOnDisc = (tile, x, y) => {

				const pixelRatio = getCanvasPixelRatio();
				ctx.scale(pixelRatio, pixelRatio);

				ctx.translate(canvas.width / 2, canvas.height / 2);

				const radiusPerTile = polarRenderingConfig.radiusPerTile;
				const centerCircleRadius = polarRenderingConfig.centerCircleRadius;

				const anglePerTile = polarRenderingConfig.getAnglePerTile();
				const halfAnglePerTile = anglePerTile / 2;

				const angle = (x / horizontalSize) * Math.PI * 2;
				let radius = polarRenderingConfig.imageMetrics.sizingRadius * 0.5 + radiusPerTile / 2;//centerCircleRadius + radiusPerTile * (y + 1);
				const middleRadius = radius - radiusPerTile / 2;
				const middleAngle = angle + halfAnglePerTile;

				ctx.fillCircle(0, 0, 10);
				ctx.scale(1, -1);
				ctx.rotate(-middleAngle);
				ctx.scaleUniformly(polarRenderingConfig.pixelPerRadius);

				ctx.fillCircle(0, middleRadius, 0.08);
				ctx.fillCircle(0, polarRenderingConfig.imageMetrics.sizingRadius, 0.08);

				//disc segment
				ctx.save();
				const discSegmentPath = new Path2D();
				ctx.rotate(Math.PI / 2);
				ctx.beginPath();
				ctx.arc(0, 0, radius, -halfAnglePerTile, halfAnglePerTile, false);
				ctx.arc(0, 0, radius - radiusPerTile, halfAnglePerTile, -halfAnglePerTile, true);
				ctx.closePath();
				ctx.restore();


				if (tile.imageData) {
					ctx.save();
					//ctx.clip();
					const imageMetrics = polarRenderingConfig.imageMetrics;
					const sizingRadius = imageMetrics.sizingRadius;
					const sizingFactor = middleRadius / sizingRadius;
					
					ctx.scaleUniformly(sizingFactor);
					ctx.translate(0, sizingRadius);
					ctx.scaleUniformly(1 / (polarRenderingConfig.pixelPerRadius));
					ctx.scale(1, -1);
					ctx.translate(-imageMetrics.centerX, -imageMetrics.centerY);
					ctx.drawImage(tile.imageData, 0, 0);
					ctx.restore();
				}

				//ctx.fillStyle = "teal";
				//ctx.fill();

				ctx.lineWidth = 0.025;
				ctx.strokeStyle = "black";
				ctx.stroke();
			};*/

			renderTileOnDisc = (tile, x, y) => {
				const pixelRatio = getCanvasPixelRatio();
				ctx.scale(pixelRatio, pixelRatio);

				ctx.translate(canvas.width / 2, canvas.height / 2);

				const radiusPerTile = polarRenderingConfig.radiusPerTile;
				const centerCircleRadius = polarRenderingConfig.centerCircleRadius;

				const anglePerTile = polarRenderingConfig.getAnglePerTile();
				const halfAnglePerTile = anglePerTile / 2;

				const angle = (x / horizontalSize) * Math.PI * 2;
				let radius = centerCircleRadius + radiusPerTile * (y + 1);
				const middleRadius = radius - radiusPerTile / 2;
				const middleAngle = angle + halfAnglePerTile;

				ctx.fillCircle(0, 0, 10);
				ctx.scale(1, -1);
				ctx.scaleUniformly(polarRenderingConfig.pixelPerRadius);

				ctx.rotate(-middleAngle);

				//disc segment
				ctx.save();
				const discSegmentPath = new Path2D();
				ctx.rotate(Math.PI / 2);
				ctx.beginPath();
				ctx.arc(0, 0, radius, -halfAnglePerTile, halfAnglePerTile, false);
				ctx.arc(0, 0, radius - radiusPerTile, halfAnglePerTile, -halfAnglePerTile, true);
				ctx.closePath();
				ctx.restore();

				{
					ctx.save();

					const wheelRadius = polarRenderingConfig.getOuterRadius() * 1.5;

					const initialMiddleAngle = (tile.initialPosition.x / horizontalSize) * Math.PI * 2 + halfAnglePerTile;
					const initialMiddleRadius = centerCircleRadius + radiusPerTile * (tile.initialPosition.y + 0.5);
					const [sin, cos] = [Math.sin(initialMiddleAngle), Math.cos(initialMiddleAngle)];
					const initialMiddlePoint = new Vector2D(sin, cos).scale(initialMiddleRadius);
					const rectCorner = new Vector2D(-wheelRadius, -wheelRadius);
					const relativeRectCorner = initialMiddlePoint.vectorTo(rectCorner);
					const localRectCornerMatrix = [
						cos, sin, -sin, cos
					];
					const localRectCorner = new Vector2D(
						relativeRectCorner.x * localRectCornerMatrix[0] + relativeRectCorner.y * localRectCornerMatrix[2],
						relativeRectCorner.x * localRectCornerMatrix[1] + relativeRectCorner.y * localRectCornerMatrix[3]
					);
					const localRectMatrix = [
						cos, sin, -sin, cos, localRectCorner.x, localRectCorner.y
					];

					ctx.translate(0, middleRadius);
					ctx.transform(...localRectMatrix);
					//ctx.strokeStyle = "red";
					//ctx.strokeRect(0, 0, wheelRadius * 2, wheelRadius * 2);
					//ctx.fillStyle = "teal";
					//ctx.fillCircle(-relativeRectCorner.x, -relativeRectCorner.y, 0.1);

					if (polarRenderingConfig.colorWheelImage) {
						const wheelRadius = polarRenderingConfig.getOuterRadius() * 1.5;
						const wheelRadiusPixels = polarRenderingConfig.pixelPerRadius * wheelRadius;
						ctx.scaleUniformly(1 / polarRenderingConfig.pixelPerRadius);
						ctx.clip();
						ctx.drawImage(polarRenderingConfig.colorWheelImage, 0, 0);
					}

					ctx.restore();
				}

				ctx.lineWidth = 0.05;
				ctx.stroke();
			};
		}


		//gradients ###
		let updateImageDataAndRepaint;
		{
			const renderGradientRect = (ctx, startX, startY) => {
				ctx.save();
				ctx.scale(1 / tileSize, 1 / tileSize);
				for (let x = 0; x < tileSize; x++) {
					for (let y = 0; y < tileSize; y++) {
						const r = 255 * ((startX * tileSize) + x) / canvas.width;
						const g = 255 * ((startY * tileSize) + y) / canvas.height;
						const b = 60;
						ctx.fillStyle = `rgb(${r},${g},${b})`;
						ctx.fillRect(x, y, 1, 1);
					}
				}
				ctx.restore();
			};
			const createRectGradientImageData = (startX, startY, continuous) => {
				const rectSize = tileSize * getCanvasPixelRatio();
				const getPixelAt = (x, y) => {
					let pixelX = (startX * rectSize);
					let pixelY = (startY * rectSize);
					if (continuous) {
						pixelX += x;
						pixelY += y;
					}
					const r = Math.round(255 * pixelX / canvas.width);
					const g = Math.round(255 * pixelY / canvas.height);
					const b = 50;
					return [r, g, b, 255];
				};
				return createRectImage(rectSize, rectSize, getPixelAt);
			};
			const createImageDataForTile = tile => {
				return createDiscGradientImageData(tile);
			};
			const updateGradientData = (tiles) => {
				return Promise.resolve();
				const promises = [];
				for (let tile of tiles) {
					const finishPromise = createImageDataForTile(tile).then(img => tile.imageData = img);
					promises.push(finishPromise);
				}
				return Promise.all(promises);
			};
			updateImageDataAndRepaint = () => {
				if (["continuous", "discrete"].includes(config.style.gradient)) {
					tiles.forEach(tile => tile.imageData = null);
					updateGradientData(tiles).then(() => requestRender());
				}
			};
			canvas.addEventListener("resized", () => updateImageDataAndRepaint());
		}


		//Tile Dragging ###
		{
			let CarykhTileDragger, SpringSnapTileDragger;
			{
				class TileDragger extends DragHelper {
					constructor(canvas) {
						super(canvas);
						this._gameStateChangedCallback = () => {
							if (this._getGameState() === "not started") {
								this.deactivate();
							}
						};
						this._getApp().addEventListener("gameStateChanged", this._gameStateChangedCallback);
					}
					deactivate() {
						this.detach();
						this._getApp().removeEventListener("gameStateChanged", this._gameStateChangedCallback);
					}
					_getApp() {
						return app;
					}
					_getGameState() {
						return this._getApp().gameState;
					}
					_onRowMoved() {
						onRowMoved();
					}
					_requestRender() {
						requestRender();
					}
					get isDragging() {
						this._dragging;
					}
				}
				CarykhTileDragger = class extends TileDragger {
					constructor(canvas) {
						super(canvas);
	
						this._prevMouseGridPoint = null;
						this._moveAnimations = [];
					}
					deactivate() {
						super.deactivate();
						this._skipAllAnimations();
					}
					_getMouseGridPoint(canvasPoint) {
						return tileBoard.canvasPointToPlanePoint(canvasPoint).quantized(1);
					}
					_skipAllAnimations() {
						this._moveAnimations.slice().forEach(ani => ani.skip());
					}
					_moveRow(direction, rowIndex, stride, animate) {
						const moveAnimations = this._moveAnimations;
						const strideVector = direction === "horizontal" ? new Vector2D(stride, 0) : new Vector2D(0, stride);
						if (animate) {
							let prevAnimProgress = 0;
							const anim = new Animation(100,
								progress => {
									progress = easing.fastInSlowOut(progress);
									tileBoard.moveTileRow(direction, rowIndex, stride * (progress - prevAnimProgress));
									prevAnimProgress = progress;
									requestRender();
								},
								() => {
									tileBoard.moveTileRow(direction, rowIndex, (1 - prevAnimProgress) * stride);
									tileBoard.stopTileRowMoving();
	
									const animIndex = moveAnimations.indexOf(anim);
									if (animIndex >= 0) {
										moveAnimations.splice(animIndex, 1);
									}
								}
							);
							anim.start(true);
							moveAnimations.push(anim);
						}
						else {
							tileBoard.moveTileRow(direction, rowIndex, stride);
							tileBoard.stopTileRowMoving();
						}
					}
					onDragStart(e) {
						this._prevMouseGridPoint = this._getMouseGridPoint(e.localMousePoint);
					}
					onDrag(e) {
						const prevMouseGridPoint = this._prevMouseGridPoint;
						const curMouseGridPoint = this._getMouseGridPoint(e.localMousePoint);
						const delta = Vector2D.vectorBetween(prevMouseGridPoint, curMouseGridPoint);
						if (delta.x !== 0 || delta.y !== 0) {
							if (this._moveAnimations.length > 0) {
								this._skipAllAnimations();
							}
							const useAnimation = !(delta.x !== 0 && delta.y !== 0);
							for (let a = 0; a < 2; a++) {
								const direction = ["horizontal", "vertical"][a];
								const prop = ["x", "y"][a];
								const orthoProp = ["y", "x"][a];
								const stride = curMouseGridPoint[prop] - prevMouseGridPoint[prop];
								const rowIndex = prevMouseGridPoint[orthoProp];
								if (stride !== 0) {
									this._moveRow(direction, rowIndex, stride, useAnimation);
									prevMouseGridPoint[prop] += stride;
								}
							}
							requestRender();
						}
						this._prevMouseGridPoint = curMouseGridPoint;
					}
				};
				SpringSnapTileDragger = class extends TileDragger {
					constructor(canvas) {
						super(canvas);
	
						this._mouseDownTileSpacePoint = null;
						this._prevSpringSpacePoint = null;
						this._prevDragPoint = null;
						this._dragVectorQueue = [];
						this._maxDragQueueSize = 7;
						this._dragVectorSum = new Vector2D();
						this._currentDragDirection = "unknown";
	
						this._draggedTile = null;
						this._targetPoint = null;
						this._springPath = [];
						this._springStrength = 15;
						this._recordedMousePath = [];
	
						this.clickCount = 0;
	
						this._prevUpdateTime = performance.now();
						this._springPhysicsActive = true;
						const loopFunc = () => {
							if (!this._springPhysicsActive) {
								return;
							}
							this._updateSpringPhysics();
							requestAnimationFrame(loopFunc);
						};
						loopFunc();
					}
	
					deactivate() {
						super.deactivate();
						this._springPhysicsActive = false;
						if (this._springPath.length > 1) {
							//this._moveTilesByPath(SpringSnapTileDragger._polylineShiftedByAHalf(this._springPath));
						}
					}
	
					_updateSpringPhysics() {
						const curTime = performance.now();
						const deltaTime = (curTime - this._prevUpdateTime) / 1000;
	
						const springPath = this._springPath;
						if (springPath.length > 1) {
							const springPathLength = SpringSnapTileDragger._getPolylinePathLength(springPath);
							if (springPathLength > 1e-3) {
								const springDeltaDistance = deltaTime * this._springStrength * springPathLength;
								const cutPath = SpringSnapTileDragger._getCutPolyline(springPath, springDeltaDistance);
								this._springPath = cutPath[1];
								const tileMovePath = cutPath[0].map(point => point.transformedComponents(c => c - 0.5));
								this._moveTilesByPath(tileMovePath);
	
								this._drawDebug();
								this._requestRender();
							}
							else {
								if (!this._dragging) {
									tileBoard.stopTileRowMoving();
								}
							}
						}
	
						this._prevUpdateTime = curTime;
					}
					_drawDebug() {
						return;
						drawDebug((ctx) => {
							ctx.save();
							ctx.scale(tileSize, tileSize);
	
							ctx.lineWidth = 0.02;
							ctx.strokeStyle = "black";
							ctx.strokePolyline(this._springPath);
							this._springPath.forEach(point => ctx.fillCircle(point.x, point.y, 0.035));
	
							ctx.restore();
						});
					}
					_getSpringSpacePoint(point) {
						return this._getCurrentLeaningPoint(point);
					}
					_handleSpringDeltaAppending(curSpringSpacePoint) {
						const springPath = this._springPath;
						const prevSpringSpacePoint = springPath[springPath.length - 1];
						const springSpaceDelta = prevSpringSpacePoint.vectorTo(curSpringSpacePoint);
						if (springSpaceDelta.x === 0 && springSpaceDelta.y === 0) {
							return;
						}
						let quantizedDeltaPath = SpringSnapTileDragger._getQuantizedGridIntersectionPath(prevSpringSpacePoint, curSpringSpacePoint);
						quantizedDeltaPath.forEach(vec => vec.transformComponents(c => c + 0.5));
						if (quantizedDeltaPath.length > 1) {
							const insertRest = (fromIndex, toIndex, restPoint, insertAfter) => {
								const deltaVec = quantizedDeltaPath[fromIndex].vectorTo(quantizedDeltaPath[toIndex]).signed();
								const fromPointToRest = quantizedDeltaPath[fromIndex].vectorTo(restPoint).signed();
								quantizedDeltaPath.splice(fromIndex + (insertAfter ? 1 : 0), 0, restPoint);
								if (fromPointToRest.equals(deltaVec)) {
									quantizedDeltaPath.splice(fromIndex + (insertAfter ? 0 : +1), 1);
								}
							};
	
							insertRest(0, 1, prevSpringSpacePoint);
							insertRest(quantizedDeltaPath.length - 1, quantizedDeltaPath.length - 2, curSpringSpacePoint, true);
						}
						else {
							quantizedDeltaPath = [];
							const center = this._targetPointTilePosition.transformedComponents(c => c + 0.5);
							const [localPrev, localCur] = [prevSpringSpacePoint, curSpringSpacePoint].map(point => center.vectorTo(point));
							quantizedDeltaPath.push(prevSpringSpacePoint, curSpringSpacePoint);
							if (!localPrev.signed().equals(localCur.signed())) {
								quantizedDeltaPath.splice(1, 0, center);
							}
						}
						quantizedDeltaPath = SpringSnapTileDragger._simplifyPolyline(quantizedDeltaPath);
	
						//try appending the delta-path
						if (springPath.length < 2) {
							springPath.push(...quantizedDeltaPath);
						}
						else {
							let curDeltaPathTargetIndex = 1;
							for (let a = 0; a < 100000; a++) {
								if (curDeltaPathTargetIndex === quantizedDeltaPath.length) {
									break;
								}
								const lastPathPoint = springPath[springPath.length - 1];
								const curStrideTarget = quantizedDeltaPath[curDeltaPathTargetIndex];
								if (springPath.length === 1) {
									springPath.push(curStrideTarget);
									curDeltaPathTargetIndex++;
									continue;
								}
								const secondLastPathPoint = springPath[springPath.length - 2];
								const lastSegmentVec = lastPathPoint.vectorTo(secondLastPathPoint);
								const lastSegmentVecSigned = lastSegmentVec.signed();
	
								const curStrideVector = lastPathPoint.vectorTo(curStrideTarget);
								const curStrideVectorSigned = curStrideVector.signed();
								if (curStrideVectorSigned.equals(lastSegmentVecSigned)) {
									const curStrideMag = SpringSnapTileDragger._getAlignedVectorLength(curStrideVector);
									const lastSegmentMag = SpringSnapTileDragger._getAlignedVectorLength(lastSegmentVec);
									if (curStrideMag < lastSegmentMag) {
										springPath[springPath.length - 1] = curStrideTarget;
									}
									else {
										springPath.splice(springPath.length - 1, 1);
									}
	
									if (curStrideMag <= lastSegmentMag) {
										curDeltaPathTargetIndex++;
									}
								}
								else {
									springPath.push(curStrideTarget);
									curDeltaPathTargetIndex++;
								}
							}
						}
						this._springPath = SpringSnapTileDragger._simplifyPolyline(springPath);
					}
	
					_moveTilesByPath(movePath) {
						if (movePath.length === 0) {
							return;
						}
						const draggedTile = this._draggedTile;
						for (let a = 1; a < movePath.length; a++) {
							const draggedTileTargetPoint = movePath[a];
							const draggedTileTargetPointQuantized = draggedTileTargetPoint.plusHalf().quantized(1);
							const prevPoint = movePath[a - 1];
							const curMoveVec = prevPoint.vectorTo(draggedTileTargetPoint);
							const curMoveDir = curMoveVec.x === 0 ? "vertical" : "horizontal";
							const curMoveAmount = curMoveDir === "horizontal" ? curMoveVec.x : curMoveVec.y;
							tileBoard.moveTileRow(curMoveDir, prevPoint.plusHalf(), curMoveAmount);
						}
					}
	
					//leaning ###
					_getLeaning(val) {
						let scale = 1;
						//const dragVecSum = this._dragVectorSum;
						//if (dragVecSum.x !== 0 || dragVecSum.y !== 0){
						//	const dragVecSumNorm = dragVecSum.normalized();
						//	scale = Math.abs(dragVecSumNorm.x - dragVecSumNorm.y);
						//}
	
						return Math.sign(val) * Math.log(Math.abs(val) + 1) * scale * 0.2;
					}
					_getSimpleLeaningPoint(point) {
						const middle = point.quantized(1).transformComponents(c => c += 0.5);
						const diff = middle.vectorTo(point);
						return Math.abs(diff.x) > Math.abs(diff.y) ?
							middle.plus(new Vector2D(diff.x, 0)) : middle.plus(new Vector2D(0, diff.y));
					}
					_getLeaningPoint(point, direction) {
						const tilePosition = point.quantized(1).plusHalf();
						const rawLeaningVector = tilePosition.vectorTo(point);
						const leaningVector = new Vector2D();
						if (direction === "horizontal") {
							leaningVector.x = this._getLeaning(rawLeaningVector.x);
						}
						else if (direction === "vertical") {
							leaningVector.y = this._getLeaning(rawLeaningVector.y);
						}
						return tilePosition.plus(leaningVector);
					}
					_getCurrentLeaningPoint(point) {
						return this._getLeaningPoint(point, this._currentDragDirection);
					}
	
					//polyline util ###
					static _getAlignedVectorLength(vector) {
						return Math.abs(vector.x !== 0 ? vector.x : vector.y);
					}
					static _getQuantizedGridIntersectionPath(startPoint, endPoint) {
						const gridIntersectionData = MathUtil.getLineToGridLineIntersections(startPoint, endPoint);
						const curPoint = startPoint.quantized(1);
						const signVector = startPoint.vectorTo(endPoint).transformComponents(Math.sign);
						const quantizedIntersectionPath = [curPoint.copy()];
						for (let intersectionData of gridIntersectionData) {
							const strideDirection = intersectionData.lineDirection === "vertical" ? "horizontal" : "vertical";
	
							if (strideDirection === "horizontal") {
								curPoint.x += signVector.x;
							}
							else if (strideDirection === "vertical") {
								curPoint.y += signVector.y;
							}
							quantizedIntersectionPath.push(curPoint.copy());
						}
						return quantizedIntersectionPath;
					}
					static _removeZeroSegmentsFromPolyline(polyline) {
						let doublesRemoved = [polyline[0]];
						for (let a = 1; a < polyline.length; a++) {
							const point = polyline[a];
							const lastFromDoublesRemoved = doublesRemoved[doublesRemoved.length - 1];
							if (!point.equals(lastFromDoublesRemoved)) {
								doublesRemoved.push(point);
							}
						}
						return doublesRemoved;
					}
					//only works with perfectly horizontal/vertical segments
					static _removeRedundantSubdivisions(polyline) {
						if (polyline.length < 2) {
							return polyline;
						}
	
						const signedDeltaVectors = [];
						for (let a = 0; a < polyline.length - 1; a++) {
							signedDeltaVectors.push(polyline[a].vectorTo(polyline[a + 1]).signed());
						}
	
						const signedVectorChangeIndices = [0];
						for (let a = 1; a < signedDeltaVectors.length; a++) {
							if (!signedDeltaVectors[a].equals(signedDeltaVectors[a - 1])) {
								signedVectorChangeIndices.push(a);
							}
						}
						signedVectorChangeIndices.push(polyline.length - 1);
	
						const withoutRedundancy = signedVectorChangeIndices.map(index => polyline[index]);
						return withoutRedundancy;
					}
					static _simplifyPolyline(polyline) {
						let simplified = polyline;
						simplified = SpringSnapTileDragger._removeZeroSegmentsFromPolyline(simplified);
						simplified = SpringSnapTileDragger._removeRedundantSubdivisions(simplified);
						return simplified;
					}
					static _getCutPolyline(polyline, pathLength) {
						const beforeCut = [polyline[0]];
						let currentLength = 0;
						let connectingIndex = 0;
						for (let a = 0; a < polyline.length - 1; a++) {
							const segmentVec = polyline[a].vectorTo(polyline[a + 1]);
							const segmentLength = SpringSnapTileDragger._getAlignedVectorLength(segmentVec);
							const nextLength = currentLength + segmentLength;
							if (nextLength <= pathLength) {
								beforeCut.push(polyline[a + 1]);
							}
							else {
								const missingSegmentLength = segmentLength - (nextLength - pathLength);
								const prop = segmentVec.x !== 0 ? "x" : "y";
								const missingEndPoint = new Vector2D();
								missingEndPoint[prop] = Math.sign(segmentVec[prop]) * missingSegmentLength;
								missingEndPoint.add(polyline[a]);
								beforeCut.push(missingEndPoint);
							}
	
							if (nextLength >= pathLength) {
								connectingIndex = nextLength > pathLength ? a + 1 : a + 2;
								break;
							}
							currentLength = nextLength;
						}
	
						const afterCut = [beforeCut[beforeCut.length - 1], ...polyline.slice(connectingIndex)];
	
						return [beforeCut, afterCut];
					}
					static _getPolylinePathLength(polyline) {
						let pathLength = 0;
						for (let a = 0; a < polyline.length - 1; a++) {
							pathLength += SpringSnapTileDragger._getAlignedVectorLength(polyline[a].vectorTo(polyline[a + 1]));
						}
						return pathLength;
					}
					static _polylineShiftedByAHalf(polyline) {
						return polyline.map(point => point.transformedComponents(c => c + 0.5));
					}
	
					onDragStart(e) {
						this.clickCount++;
						if (this.clickCount > 1) {
							//this.onDrag(e);
							//return;
						}
	
						//handle the current spring path immediately
						if (this._springPath.length > 0) {
							this._moveTilesByPath(this._springPath.map(point => point.transformedComponents(c => c - 0.5)));
							tileBoard.stopTileRowMoving();
						}
						this._springPath = [];
	
						const tileSpacePoint = tileBoard.canvasPointToPlanePoint(e.localMousePoint);
						this._mouseDownTileSpacePoint = tileSpacePoint;
						this._targetPoint = tileSpacePoint.copy();
						this._targetPointTilePosition = this._targetPoint.quantized(1);
	
						this._draggedTile = tileBoard.getTileAtPlanePoint(this._targetPointTilePosition);
						this._prevDragPoint = e.localMousePoint;
						this._prevSpringSpacePoint = this._getSpringSpacePoint(tileSpacePoint);
						this._springPath.push(this._targetPointTilePosition.transformedComponents(c => c + 0.5));
	
						this._drawDebug();
						this._requestRender();
					}
					onDrag(e) {
						const springPath = this._springPath;
						const tileSpacePoint = tileBoard.canvasPointToPlanePoint(e.localMousePoint);
						this._targetPoint = tileSpacePoint.copy();
						this._targetPointTilePosition = tileBoard.planePointToBoardGridPoint(tileSpacePoint);
	
						//drag direction
						const curDragVector = e.localMousePoint.vectorTo(this._prevDragPoint);
						if (curDragVector.x === 0 && curDragVector.y === 0) {
							return;
						}
						this._dragVectorQueue.unshift(curDragVector);
						if (this._dragVectorQueue.length > this._maxDragQueueSize) {
							this._dragVectorQueue.pop();
						}
						if (this._dragVectorQueue.length === this._maxDragQueueSize) {
							const dragVectorSum = new Vector2D();
							this._dragVectorQueue.forEach(vec => dragVectorSum.add(vec.transformedComponents(Math.abs)));
							this._currentDragDirection = Math.abs(dragVectorSum.x) > Math.abs(dragVectorSum.y) ? "horizontal" : "vertical";
							this._dragVectorSum = dragVectorSum;
						}
	
						//construct and append the delta-path
						const curSpringSpacePoint = this._getSpringSpacePoint(tileSpacePoint);
						this._handleSpringDeltaAppending(curSpringSpacePoint);
	
						this._prevDragPoint = e.localMousePoint;
						this._prevSpringSpacePoint = curSpringSpacePoint;
						this._drawDebug();
						this._requestRender();
					}
					onDragEnd(e) {
	
						this._dragVectorQueue = [];
						this._currentDragDirection = "unknown";
	
						this._handleSpringDeltaAppending(this._prevSpringSpacePoint.quantized().transformedComponents(c => c + 0.5));
	
						this._drawDebug();
						this._requestRender();
					}
				}
			}
			let currentDragger = null;
			app.addEventListener("gameStateChanged", e => {
				if (app.gameState === "finished" && currentDragger !== null){
					//currentDragger.deactivate();
				}
			});
			app.addEventListener("configChanged", e => {
				const draggerMap = {
					"carykh": (canvas) => new CarykhTileDragger(canvas),
					"spring and snap": (canvas) => new SpringSnapTileDragger(canvas)
				};
				if (currentDragger !== null) {
					currentDragger.deactivate();
				}
				currentDragger = draggerMap[e.detail.newConfig.draggingMethod](canvas);
			});
		}
		 
		const onGameStarted = () => {

			initTiles();
			initImageMetrics();
			updateCanvasSize();
		
			if (config.scrambleOnStart){
				tileBoard.performRandomMoves(horizontalSize * verticalSize * 5);
			}

			tileBoard.init();

			requestRender();
		};
		app.addEventListener("gameStateChanged", e => {
			if (e.detail.transition === "start"){
				onGameStarted();
			}
			else if (e.detail.transition === "restart"){
				app.applyConfig(config);
				onGameStarted(config);
			}
		});
	}
</script>

<!-- game ui, stats -->
<script>
	{
		//game timer
		/*{
			const gameTimer = {};
			const getTime = () => window.performance.now();
			let state = "not running";
			gameTimer.start = () => {
				state = "running";
				prevTime = getTime();
				elapsedTime = 0;
				tickFunc();
			};
			gameTimer.pause = () => {
				state = "paused";
			};
			gameTimer.stop = () => {
				state = "not running";
			};
			gameTimer.reset = () => {
				state = "not running";
				labelElement.innerHTML = "0s";
			};
			gameTimer.resume = () => {
				state = "running";
				prevTime = performance.now();
			};
			Object.defineProperty(gameTimer, "isRunning", { get: () => state === "running" });
			
	
			const labelElement = document.querySelector("#elapsed-time-element");
			let elapsedTime = 0;
			let prevTime = 0;
			let updateTimeLabel = () => {
				
				const curTime = getTime();
				const deltaTime = curTime - prevTime;
				prevTime = curTime;
				if (state === "paused"){
					return;
				}
				elapsedTime += deltaTime;
	
				let timeString = "";
	
				const millisString = (elapsedTime % 1000).toString().slice(0, 2);
				timeString = `${millisString}ms`;
	
				const elapsedSeconds = Math.floor(elapsedTime / 1000);
				const seconds = elapsedSeconds % 60;
				timeString = `${seconds}s ${timeString}`;
	
				const elapsedMinutes = Math.floor(elapsedSeconds / 60);
				if (elapsedMinutes > 0){
					timeString = `${elapsedMinutes % 60}m ${timeString}`;
				}
	
				const elapsedHours = Math.floor(elapsedMinutes / 60);
				if (elapsedHours > 0){
					timeString = `${elapsedHours}h ${timeString}`;
				}
	
				labelElement.innerHTML = timeString;
			};
			let tickFunc = () => {
				if (state === "not running"){
					return;
				}
				updateTimeLabel();
				window.requestAnimationFrame(tickFunc);
			};
	
			app.addEventListener("gameStateChanged", e => {
				if (app.gameState === "running"){
					if (app.prevGameState !== null && app.prevGameState === "paused"){
						gameTimer.resume();
					}
					else {
						gameTimer.start();
					}
				}
				else if (app.gameState === "finished"){
					gameTimer.stop();
				}
				else if (app.gameState === "not started"){
					gameTimer.reset();
				}
				else if (app.gameState === "paused"){
					gameTimer.pause();
				}
			});
		}*/
	
		//number of moves - counter
		{
			const updateMoveLabel = (newValue) => {
				document.querySelector("#number-moves-element").innerHTML = app.numberOfMoves.toString();
			};
			app.addEventListener("rowMoved", e => {
				updateMoveLabel();
			});
			app.addEventListener("gameStateChanged", e => {
				if (app.gameState === "not started") {
					updateMoveLabel();
				}
			});
		}
	
		//restart button
		document.querySelector("#restart-button").addEventListener("click", () => app.restart());
	}
</script>

<!-- unused -->
<script>
	/*
	const getTileAtPosition = (tiles, position) => {
		return tiles.find(tile => isTileAtPosition(tile, position.x, position.y));
	};
	const isTilePositionComponentAt = (tilePositionComponent, target, loopSize) => {
		target = loopNum(0, loopSize, target);
		tilePositionComponent = loopNum(0, loopSize, tilePositionComponent);
		return tilePositionComponent === target;
	};
	const isTileAtPosition = (tile, x, y) => {
		const tilePosition = tile.position;
		if (x !== null && !isTilePositionComponentAt(tilePosition.x, x, horizontalSize)) {
			return false;
		}
		if (y !== null && !isTilePositionComponentAt(tilePosition.y, y, verticalSize)) {
			return false;
		}
		return true;
	};
	const getSolveMoves = (solveMethod, tiles) => {
		tiles = tiles.map(tile => {
			return {
				initialPosition: tile.initialPosition.copy(),
				position: tile.position.copy()
			}
		});
		const getTileAtInitialPosition = (tiles, x, y) => {
			return tiles.find(tile => isTileAtPosition(tile, x, y));
		};

		if (solveMethod === "naive") {
			const moves = [];
			const dragTileTo = (tile, direction, target) => {

				const prop = direction === "horizontal" ? "x" : "y";
				const loopSize = direction === "horizontal" ? horizontalSize : verticalSize;
				if (isTilePositionComponentAt(tile.position[prop], target, loopSize)) {
					return;
				}

				const delta = target - (direction === "horizontal" ? tile.position.x : tile.position.y);
				const rowIndex = direction === "horizontal" ? tile.position.y : tile.position.x;
				const move = {
					direction: direction,
					stride: delta,
					rowIndex: rowIndex
				};
				moves.push(move);
				tile.position[prop] = target;
			};
			const lastX = horizontalSize - 1;
			for (let a = 0; a < verticalSize - 1; a++) {
				for (let b = 0; b < horizontalSize - 1; b++) {
					const targetPoint1 = new Vector2D(lastX, a);
					const tile = getTileAtInitialPosition(tiles, targetPoint1.x, targetPoint1.y);
					if (isTileAtPosition(tile, targetPoint1.x, targetPoint1.y)) {
						continue;
					}
					if (isTileAtPosition(tile, null, targetPoint1.y)) {

					}
					else {
						dragTileTo(tile, "horizontal", targetPoint1.x);
						dragTileTo(tile, "vertical", targetPoint1.y);
						dragTileTo(tile, "horizontal", lastX - 1);
					}
				}
			}
		}
	};
	*/

	//dragging
	{
		/*if (config.draggingMethod === "carykh") {
			const dragger = new CarykhTileDragger(canvas);
		}
		else if (config.draggingMethod === "move and snap") {
			//leaning and snap to smaller center rect
			{
				let dragging = false;
				let mouseDownTileSpacePoint = null;
				let prevMouseDragSpacePoint = null;

				//leaning
				let leaningRowTiles = null;
				let leaningRowsInitialPositions = null;
				const nonLeanZoneSize = 0.34;
				const setupLeaning = (tileCoo) => {
					leaningRowTiles = tiles.filter(tile => {
						return isTilePositionComponentAt(tile.position.x, tileCoo.x, horizontalSize) ||
							isTilePositionComponentAt(tile.position.y, tileCoo.y, verticalSize);
					});
					leaningRowsInitialPositions = new Map();
					leaningRowTiles.forEach(tile => leaningRowsInitialPositions.set(tile, tile.position.copy()));
				};
				const restoreLeaningTiles = () => leaningRowTiles.forEach(tile => tile.position = leaningRowsInitialPositions.get(tile));
				const updateLeaning = (centerTileCoo, dragCellSpacePoint) => {
					//center rect
					const absPoint = dragCellSpacePoint.transformedComponents(Math.abs);
					if (absPoint.x < nonLeanZoneSize && absPoint.y < nonLeanZoneSize) {
						return;
					}
					const leanDirection = absPoint.x > absPoint.y ? "horizontal" : "vertical";
					const leanVector = leanDirection === "horizontal" ?
						new Vector2D(dragCellSpacePoint.x, 0) :
						new Vector2D(0, dragCellSpacePoint.y);
					const tileFilter = leanDirection === "horizontal" ?
						(tile => isTileAtPosition(tile, null, centerTileCoo.y)) :
						(tile => isTileAtPosition(tile, centerTileCoo.x, null));
					const curLeaningTiles = leaningRowTiles.filter(tileFilter);
					curLeaningTiles.forEach(tile => tile.position = leaningRowsInitialPositions.get(tile).plus(leanVector));
				};

				const onDragStart = e => {
					//prevent multi-touch for now
					if (dragging) {
						return;
					}
					dragging = true;
					const tileSpacePoint = e.localMousePoint.toTileSpace();
					const tileCoo = tileSpacePoint.quantized(1);
					mouseDownTileSpacePoint = tileCoo.plus(new Vector2D(0.5, 0.5));
					prevMouseDragSpacePoint = mouseDownTileSpacePoint.vectorTo(tileSpacePoint);
					setupLeaning(tileCoo);
					updateLeaning(tileCoo, prevMouseDragSpacePoint);
					requestRender();
				};
				const onDrag = e => {
					const prevMouseDragGridPoint = prevMouseDragSpacePoint.rounded();
					const curMouseDragSpacePoint = mouseDownTileSpacePoint.vectorTo(e.localMousePoint.toTileSpace());
					const curMouseDragGridPoint = curMouseDragSpacePoint.rounded();
					const centerTileCoo = mouseDownTileSpacePoint.plus(curMouseDragGridPoint).quantized(1);
					const gridDelta = prevMouseDragGridPoint.vectorTo(curMouseDragGridPoint);
					const dragCellSpacePoint = curMouseDragGridPoint.vectorTo(curMouseDragSpacePoint);

					restoreLeaningTiles();

					if (!(gridDelta.x === 0 && gridDelta.y === 0)) {
						const gridIntersections = getLineToGridLineIntersections(...[prevMouseDragSpacePoint, curMouseDragSpacePoint].map(point => point.plus(new Vector2D(0.5, 0.5))));
						const gridDeltaSign = gridDelta.transformedComponents(Math.sign);
						let movementCenterTile = mouseDownTileSpacePoint.plus(prevMouseDragGridPoint).quantized(1);
						for (let intersectionEntry of gridIntersections) {
							const moveStride = intersectionEntry.lineDirection === "vertical" ?
								new Vector2D(gridDeltaSign.x, 0) : new Vector2D(0, gridDeltaSign.y);
							const tileFilter = intersectionEntry.lineDirection === "vertical" ?
								(tile => isTilePositionComponentAt(tile.position.y, movementCenterTile.y, verticalSize)) :
								(tile => isTilePositionComponentAt(tile.position.x, movementCenterTile.x, horizontalSize));
							tiles.filter(tileFilter).forEach(tile => tile.position = tile.position.plus(moveStride));
							movementCenterTile = movementCenterTile.plus(moveStride);
						}
						setupLeaning(centerTileCoo);
					}

					updateLeaning(centerTileCoo, dragCellSpacePoint);
					requestRender();

					prevMouseDragSpacePoint = curMouseDragSpacePoint;
				};
				const onDragEnd = e => {
					dragging = false;
					restoreLeaningTiles();
					requestRender();
				};

				const dragger = new DragHelper(canvas);
				dragger.onDragStart = onDragStart;
				dragger.onDrag = onDrag;
				dragger.onDragEnd = onDragEnd;
			}
		}
		else if (config.draggingMethod === "spring snap") {
			new SpringSnapTileDragger(canvas);
		}*/

		//move rows by raw delta pixels
		/*{
			let dragging = false;
			let initialRowCoordinateMap = null;
			let dragDirection = "none";
			let getDraggedSquares = null;
			
			let mouseDownCanvasPoint = null;
			let mouseDownScreenPoint = null;
			let mouseDownGridPoint = null;

			canvas.addEventListener("mousedown", e => {
				mouseDownCanvasPoint = new Vector2D(e.offsetX, e.offsetY);
				mouseDownScreenPoint = new Vector2D(e.screenX, e.screenY);
				dragging = true;			
			});
			document.addEventListener("mousemove", e => {
				if (!dragging){
					return;
				}
				
				const currentMouseScreenPoint = new Vector2D(e.screenX, e.screenY);
				if (dragDirection === "none"){
					const dragVector = Vector2D.vectorBetween(mouseDownScreenPoint, currentMouseScreenPoint);
					const dragDistance = Math.hypot(dragVector.x, dragVector.y);
					if (dragDistance > 10){
						dragDirection = Math.abs(dragVector.x) > Math.abs(dragVector.y) ? "horizontal" : "vertical";
						mouseDownGridPoint = Vector2D.quantized(Vector2D.divide(mouseDownCanvasPoint, tileSize), 1);
						initialRowCoordinateMap = new Map();
						getDraggedSquares = dragDirection === "horizontal" ? 
							(() => getTilesInRow("horizontal", mouseDownGridPoint.y)) : 
							(() => getTilesInRow("vertical", mouseDownGridPoint.x));
						getDraggedSquares().forEach(square => initialRowCoordinateMap.set(square, square.position.copy()));
					}
					else {
						return;
					}
				}

				let mousePositionDelta = Vector2D.vectorBetween(mouseDownScreenPoint, currentMouseScreenPoint);
				mousePositionDelta = Vector2D.divide(mousePositionDelta, tileSize);
				//["x", "y"].forEach(prop => deltaCoo[prop] = Math.round(deltaCoo[prop]));
				const movedProp = dragDirection === "horizontal" ? "x" : "y";
				getDraggedSquares().forEach(square => {
					square.position[movedProp] = initialRowCoordinateMap.get(square)[movedProp] + mousePositionDelta[movedProp]
				});
				requestRender();
			});
			document.addEventListener("mouseup", e => {
				if (!dragging){
					return;
				}
				dragging = false;
				dragDirection = "none";
				snapTilesToGrid(getDraggedSquares());
				requestRender();
			});
		}*/

		//move touched tile to mouse point
		/*{
			const updateRowPosition = (touchTilePosition, rowTiles, mousePoint) => {
				const centerTile = rowTiles[0];
				const centerPoint = Vector2D.add(touchTilePosition, new Vector2D(0.5, 0.5));
				const deltaVector = Vector2D.vectorBetween(centerPoint, mousePoint);
				const biggerProp = Math.abs(deltaVector.x) > Math.abs(deltaVector.y) ? "x" : "y";
				const shift = new Vector2D();
				shift[biggerProp] = Math.sign(deltaVector[biggerProp]) * Math.log(Math.abs(deltaVector[biggerProp]) + 1) * 1;
				centerTile.position = Vector2D.add(touchTilePosition, shift);
				requestRender();
			};
			
			const getCoordinateData = e => {
				const mousePoint = new Vector2D(e.offsetX, e.offsetY);
				const scaledMousePoint = Vector2D.divide(mousePoint, tileSize);
				const quantizedMousePoint = Vector2D.quantized(scaledMousePoint, 1);
				return {
					tileSpaceMousePoint: scaledMousePoint,
					tileSpaceMousePointQuantized: quantizedMousePoint
				};
			};
			
			const updateRowDragging = (leaningData, prevTilePoint, curTilePoint) => {
				
				if (prevTilePoint !== null){
					const intersectionValues = getLineToGridLineIntersections(prevTilePoint, curTilePoint);
					if (intersectionValues.length > 0){
						leaningData.rowTiles.forEach(tile => tile.position = leaningData.initialPositionsMap.get(tile));
						const dragVector = Vector2D.vectorBetween(prevTilePoint, curTilePoint);
						const dragSigns = [Math.sign(dragVector.x), Math.sign(dragVector.y)];
						let dragRefPosition = Vector2D.quantized(prevTilePoint.copy(), 1);
						for (let intersectionVal of intersectionValues){
							const intersectionDirection = intersectionVal.lineDirection === "horizontal" ? "vertical" : "horizontal";
							const dragStride = intersectionDirection === "horizontal" ? new Vector2D(dragSigns[0], 0) : new Vector2D(0, dragSigns[1]);
							const rowIndex = intersectionDirection === "horizontal" ? dragRefPosition.y : dragRefPosition.x;
							const draggedTiles = getTilesInRow(intersectionDirection, rowIndex);
							draggedTiles.forEach(tile => tile.position = Vector2D.add(tile.position, dragStride));
						}
						leaningData = null;
					}
				}
				
				const curTilePointSnapped = Vector2D.quantized(curTilePoint, 1);
				const touchedTile = getTileAtPosition(curTilePointSnapped);
				const curTileCenter = Vector2D.add(curTilePointSnapped, new Vector2D(0.5, 0.5));
				let rawLeanVector = Vector2D.vectorBetween(curTileCenter, curTilePoint);
				const leanDirection = Math.abs(rawLeanVector.x) > Math.abs(rawLeanVector.y) ? "horizontal" : "vertical";
				const leanProp = leanDirection === "horizontal" ? "x" : "y";
				const leanVal = rawLeanVector[leanProp];
				const leanVector = new Vector2D();
				leanVector[leanProp] = Math.sign(leanVal) * Math.log(Math.abs(leanVal) + 1) * 0.5;
				
				
				//leaningData: { direction, centerTile, rowTiles, initialPositionsMap }
				const leaningChanged = leaningData === null || leaningData.direction !== leanDirection || leaningData.centerTile !== touchedTile;
				if (leaningChanged){
					//restore positions
					if (leaningData !== null){
						leaningData.rowTiles.forEach(tile => tile.position = leaningData.initialPositionsMap.get(tile));
					}

					const rowIndex = leanDirection === "horizontal" ? curTilePointSnapped.y : curTilePointSnapped.x;
					const rowTiles = getTilesInRow(leanDirection, rowIndex);
					const initialPositionsMap = new Map();
					rowTiles.forEach(tile => initialPositionsMap.set(tile, tile.position.copy()));
					leaningData = {
						direction: leanDirection,
						centerTile: touchedTile,
						rowTiles: rowTiles,
						initialPositionsMap: initialPositionsMap
					};
				}
				//apply leaning
				leaningData.rowTiles.forEach(tile => {
					tile.position = Vector2D.add(leaningData.initialPositionsMap.get(tile), leanVector);
				});

				return leaningData;
			};


			let dragging = false;
			let prevTileSpaceMousePoint = null;
			let leaningData = null;

			canvas.addEventListener("mousedown", e => {
				dragging = true;
				const cooData = getCoordinateData(e);
				leaningData = updateRowDragging(leaningData, null, cooData.tileSpaceMousePoint);
				requestRender();
			});
			document.addEventListener("mousemove", e => {
				if (!dragging){
					return;
				}
				const cooData = getCoordinateData(e);
				leaningData = updateRowDragging(leaningData, prevTileSpaceMousePoint, cooData.tileSpaceMousePoint);
				prevTileSpaceMousePoint = cooData.tileSpaceMousePoint;
				requestRender();
			});
			document.addEventListener("mouseup", e => {
				if (!dragging){
					return;
				}
				snapTilesToGrid(tiles);
				dragging = false;
				requestRender();
			});
		}*/

		//leaning plus animation
		/*{
			//tileSpace -> downscaled and unsnapped
			//tileGrid -> downscaled and snapped
			//gridSpace -> tileSpace point relative to a given point (in this case the mouseDownPoint)

			//state, "not dragging", "start leaning", "leaning", "moving", "end leaning" 
			let state = "not dragging";
			let mouseDownTileSpacePoint = null;
			let prevMouseDragSpacePoint = null;
			let currentMoveAnimation = null;

			//leaning ###	
			let leaningRowsInitialPositions = null;
			let leaningRowTiles = null;
			const setupLeaningData = (tilePosition) => {
				leaningRowTiles = tiles.filter(tile => tile.position.x === tilePosition.x || tile.position.y === tilePosition.y);
				leaningRowsInitialPositions = new Map();
				for (let tile of leaningRowTiles){
					leaningRowsInitialPositions.set(tile, tile.position.copy());
				}
			};
			const updateLeaning = (dragSpacePoint) => {
				const dragGridPoint = dragSpacePoint.quantized(1);
				const dragCellPoint = dragGridPoint.vectorTo(dragSpacePoint);
				const dragTileCoo = mouseDownTileSpacePoint.plus(dragGridPoint).quantized(1);

				const leanDirection = Math.abs(dragCellPoint.x) > Math.abs(dragCellPoint.y) ? "horizontal" : "vertical";
				let leanValue = leanDirection === "horizontal" ? dragCellPoint.x : dragCellPoint.y;
				const nonLeanZoneSize = 0.15;
				leanValue = Math.abs(leanValue) < nonLeanZoneSize ? 0 : Math.sign(leanValue) * (Math.abs(leanValue) - nonLeanZoneSize)
				leanValue = Math.sign(leanValue) * Math.log(Math.abs(leanValue) + 1) * 0.5;
				
				const leanVector = leanDirection === "horizontal" ? new Vector2D(leanValue, 0) : new Vector2D(0, leanValue);
				
				const leanTileFilter = leanDirection === "horizontal" ? 
					(tile => tile.position.y === dragTileCoo.y) : 
					(tile => tile.position.x === dragTileCoo.x);
				const leanTiles = leaningRowTiles.filter(leanTileFilter);
				leaningRowTiles.forEach(tile => {
					tile.position = leaningRowsInitialPositions.get(tile);
					if (leanTileFilter(tile)){
						tile.position = tile.position.plus(leanVector);
					}
				});
			};

			
			const moveRowWithAnimation = (direction, rowIndex, stride, animate) => {
				const strideVector = direction === "horizontal" ? new Vector2D(stride, 0) : new Vector2D(0, stride);
				const rowTiles = getTilesInRow(direction, rowIndex);
				if (animate){
					const initialPositionsMap = new Map();
					rowTiles.forEach(tile => initialPositionsMap.set(tile, tile.position.copy()));
					const anim = new Animation(100, 
						progress => {
							progress = easing.fastInSlowOut(progress);
							rowTiles.forEach(tile => {
								tile.position = Vector2D.add(initialPositionsMap.get(tile), Vector2D.multiply(strideVector, progress))
							});
							requestRender();
						}, 
						() => {
							rowTiles.forEach(tile => {
								tile.position = Vector2D.add(initialPositionsMap.get(tile), strideVector)
							});
							const animIndex = moveAnimations.indexOf(anim);
							if (animIndex >= 0){
								moveAnimations.splice(animIndex, 1);
							}
						}
					);
				}
				else {
					rowTiles.forEach(tile => {
						tile.position = Vector2D.add(tile.position, strideVector)
					});
				}
			};
			

			const dragger = new DragHelper(canvas);
			dragger.onDragStart = e => {
				const mouseDownTileCoo = e.localMousePoint.divide(tileSize).quantized(1);
				mouseDownTileSpacePoint = mouseDownTileCoo.plus(new Vector2D(0.5, 0.5));
				prevMouseDragSpacePoint = mouseDownTileSpacePoint.vectorTo(e.localMousePoint.divide(tileSize));
				setupLeaningData(mouseDownTileCoo);
				updateLeaning(prevMouseDragSpacePoint);
				requestRender();
			};
			dragger.onDrag = e => {
				
				const prevMouseDragGridPoint = prevMouseDragSpacePoint.quantized(1);
				const curMouseTileSpacePoint = e.localMousePoint.divide(tileSize);
				const curMouseDragSpacePoint = mouseDownTileSpacePoint.vectorTo(curMouseTileSpacePoint);
				const curMouseDragGridPoint = curMouseDragSpacePoint.quantized(1);
				const gridDelta = prevMouseDragGridPoint.vectorTo(curMouseDragGridPoint);
				
				if (gridDelta.x !== 0 || gridDelta.y !== 0){
					if (currentMoveAnimation !== null){
						currentMoveAnimation.skip();
					}
					const useAnimation = !(gridDelta.x !== 0 && gridDelta.y !== 0);
					for (let a = 0; a < 2; a++){
						const direction = ["horizontal", "vertical"][a];
						const prop = ["x", "y"][a];
						const orthoProp = ["y", "x"][a];
						const stride = curMouseGridPoint[prop] - prevMouseGridPoint[prop];
						const rowIndex = prevMouseGridPoint[orthoProp];
						if (stride !== 0){
							moveRowWithAnimation(direction, rowIndex, stride, useAnimation);
						}
						prevMouseGridPoint[prop] += stride;
					}
					setupLeaningData(mouseDownTileCoo);
				}

				//leaning
				updateLeaning(curMouseDragSpacePoint);

				requestRender();
				prevMouseDragSpacePoint = curMouseDragSpacePoint;
			};
		}*/
	}
</script>

<!-- settings input -->
<script>
	{
		const queryById = id => document.querySelector("#"+id);

		const appSettings = {};
		window.appSettings = appSettings;
		appSettings.getConfig = () => {
			return {
				numberOfHorizontalTiles: parseInt(queryById("width-input").value),
				numberOfVerticalTiles: parseInt(queryById("height-input").value),
				scrambleOnStart: queryById("scramble-on-start-input").checked,
				draggingMethod: queryById("dragging-method-input").value,
				style: {
					gradient: queryById("gradient-input").value,
					labels: "letters"
				}
			};
		};
	}
</script>

<!-- settings reveal -->
<script src="CircularRevealHelper.js"></script>
<script>
	{
		const settingsContainer = document.querySelector("#settings-container");
		const settingsButton = document.querySelector("#settings-button");
		const revealHelper = new CircularRevealHelper(settingsButton, settingsContainer);
		settingsButton.addEventListener("click", () => revealHelper.toggleReveal());
		revealHelper.addEventListener("revealStateChanged", e => {
			const state = e.detail.revealState;
			if (state === "opening"){
				app.pause();
			}
			else if (state === "closed"){
				app.resume();
			}
			else if (state === "closing"){
				app.applyConfig(appSettings.getConfig());
			}
		});
	}
</script>

<!-- start -->
<script>
	app.applyConfig(appSettings.getConfig());
	app.start();
</script>

<!-- pause if page is blurred -->
<script>
	{
		let hidden, visibilityChange;
		if (typeof document.hidden !== "undefined") { // Opera 12.10 and Firefox 18 and later support 
			hidden = "hidden";
			visibilityChange = "visibilitychange";
		} 
		else if (typeof document.msHidden !== "undefined") {
			hidden = "msHidden";
			visibilityChange = "msvisibilitychange";
		} 
		else if (typeof document.webkitHidden !== "undefined") {
			hidden = "webkitHidden";
			visibilityChange = "webkitvisibilitychange";
		}

		const handleVisibilityChange = () => {
			if (document[hidden]) {
				app.pause();
			} 
			else {
				app.resume();
			}
		};
		document.addEventListener(visibilityChange, handleVisibilityChange, false);
	}
</script>

</body>
</html>